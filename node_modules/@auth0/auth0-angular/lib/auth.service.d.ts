import { OnDestroy } from '@angular/core';
import { Auth0Client, RedirectLoginOptions, PopupLoginOptions, PopupConfigOptions, LogoutOptions, GetTokenSilentlyOptions, GetTokenWithPopupOptions } from '@auth0/auth0-spa-js';
import { Observable } from 'rxjs';
import { AbstractNavigator } from './abstract-navigator';
import { Location } from '@angular/common';
import * as ɵngcc0 from '@angular/core';
export declare class AuthService implements OnDestroy {
    private auth0Client;
    private location;
    private navigator;
    private isLoadingSubject$;
    private isAuthenticatedSubject$;
    private errorSubject$;
    private ngUnsubscribe$;
    /**
     * Emits boolean values indicating the loading state of the SDK.
     */
    readonly isLoading$: Observable<boolean>;
    /**
     * Emits boolean values indicating the authentication state of the user. If `true`, it means a user has authenticated.
     * This depends on the value of `isLoading$`, so there is no need to manually check the loading state of the SDK.
     */
    readonly isAuthenticated$: Observable<boolean>;
    /**
     * Emits details about the authenticated user when `isAuthenticated$` is `true`.
     */
    readonly user$: Observable<any>;
    /**
     * Emits ID token claims when `isAuthenticated$` is `true`.
     */
    readonly idTokenClaims$: Observable<import("@auth0/auth0-spa-js").IdToken>;
    /**
     * Emits errors that occur during login, or when checking for an active session on startup.
     */
    readonly error$: Observable<Error>;
    constructor(auth0Client: Auth0Client, location: Location, navigator: AbstractNavigator);
    /**
     * Called when the service is destroyed
     */
    ngOnDestroy(): void;
    /**
     * ```js
     * loginWithRedirect(options);
     * ```
     *
     * Performs a redirect to `/authorize` using the parameters
     * provided as arguments. Random and secure `state` and `nonce`
     * parameters will be auto-generated.
     *
     * @param options The login options
     */
    loginWithRedirect(options?: RedirectLoginOptions): Observable<void>;
    /**
     * ```js
     * await loginWithPopup(options);
     * ```
     *
     * Opens a popup with the `/authorize` URL using the parameters
     * provided as arguments. Random and secure `state` and `nonce`
     * parameters will be auto-generated. If the response is successful,
     * results will be valid according to their expiration times.
     *
     * IMPORTANT: This method has to be called from an event handler
     * that was started by the user like a button click, for example,
     * otherwise the popup will be blocked in most browsers.
     *
     * @param options The login options
     * @param config Configuration for the popup window
     */
    loginWithPopup(options?: PopupLoginOptions, config?: PopupConfigOptions): Observable<void>;
    /**
     * ```js
     * logout();
     * ```
     *
     * Clears the application session and performs a redirect to `/v2/logout`, using
     * the parameters provided as arguments, to clear the Auth0 session.
     * If the `federated` option is specified it also clears the Identity Provider session.
     * If the `localOnly` option is specified, it only clears the application session.
     * It is invalid to set both the `federated` and `localOnly` options to `true`,
     * and an error will be thrown if you do.
     * [Read more about how Logout works at Auth0](https://auth0.com/docs/logout).
     *
     * @param options The logout options
     */
    logout(options?: LogoutOptions): void;
    /**
     * ```js
     * getAccessTokenSilently(options).subscribe(token => ...)
     * ```
     *
     * If there's a valid token stored, return it. Otherwise, opens an
     * iframe with the `/authorize` URL using the parameters provided
     * as arguments. Random and secure `state` and `nonce` parameters
     * will be auto-generated. If the response is successful, results
     * will be valid according to their expiration times.
     *
     * If refresh tokens are used, the token endpoint is called directly with the
     * 'refresh_token' grant. If no refresh token is available to make this call,
     * the SDK falls back to using an iframe to the '/authorize' URL.
     *
     * This method may use a web worker to perform the token call if the in-memory
     * cache is used.
     *
     * If an `audience` value is given to this function, the SDK always falls
     * back to using an iframe to make the token exchange.
     *
     * Note that in all cases, falling back to an iframe requires access to
     * the `auth0` cookie, and thus will not work in browsers that block third-party
     * cookies by default (Safari, Brave, etc).
     *
     * @param options The options for configuring the token fetch.
     */
    getAccessTokenSilently(options?: GetTokenSilentlyOptions): Observable<string>;
    /**
     * ```js
     * getTokenWithPopup(options).subscribe(token => ...)
     * ```
     *
     * Get an access token interactively.
     *
     * Opens a popup with the `/authorize` URL using the parameters
     * provided as arguments. Random and secure `state` and `nonce`
     * parameters will be auto-generated. If the response is successful,
     * results will be valid according to their expiration times.
     */
    getAccessTokenWithPopup(options?: GetTokenWithPopupOptions): Observable<string>;
    private shouldHandleCallback;
    private handleRedirectCallback;
    static ɵfac: ɵngcc0.ɵɵFactoryDef<AuthService, never>;
}

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYXV0aC5zZXJ2aWNlLmQudHMiLCJzb3VyY2VzIjpbImF1dGguc2VydmljZS5kLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgT25EZXN0cm95IH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBBdXRoMENsaWVudCwgUmVkaXJlY3RMb2dpbk9wdGlvbnMsIFBvcHVwTG9naW5PcHRpb25zLCBQb3B1cENvbmZpZ09wdGlvbnMsIExvZ291dE9wdGlvbnMsIEdldFRva2VuU2lsZW50bHlPcHRpb25zLCBHZXRUb2tlbldpdGhQb3B1cE9wdGlvbnMgfSBmcm9tICdAYXV0aDAvYXV0aDAtc3BhLWpzJztcbmltcG9ydCB7IE9ic2VydmFibGUgfSBmcm9tICdyeGpzJztcbmltcG9ydCB7IEFic3RyYWN0TmF2aWdhdG9yIH0gZnJvbSAnLi9hYnN0cmFjdC1uYXZpZ2F0b3InO1xuaW1wb3J0IHsgTG9jYXRpb24gfSBmcm9tICdAYW5ndWxhci9jb21tb24nO1xuZXhwb3J0IGRlY2xhcmUgY2xhc3MgQXV0aFNlcnZpY2UgaW1wbGVtZW50cyBPbkRlc3Ryb3kge1xuICAgIHByaXZhdGUgYXV0aDBDbGllbnQ7XG4gICAgcHJpdmF0ZSBsb2NhdGlvbjtcbiAgICBwcml2YXRlIG5hdmlnYXRvcjtcbiAgICBwcml2YXRlIGlzTG9hZGluZ1N1YmplY3QkO1xuICAgIHByaXZhdGUgaXNBdXRoZW50aWNhdGVkU3ViamVjdCQ7XG4gICAgcHJpdmF0ZSBlcnJvclN1YmplY3QkO1xuICAgIHByaXZhdGUgbmdVbnN1YnNjcmliZSQ7XG4gICAgLyoqXG4gICAgICogRW1pdHMgYm9vbGVhbiB2YWx1ZXMgaW5kaWNhdGluZyB0aGUgbG9hZGluZyBzdGF0ZSBvZiB0aGUgU0RLLlxuICAgICAqL1xuICAgIHJlYWRvbmx5IGlzTG9hZGluZyQ6IE9ic2VydmFibGU8Ym9vbGVhbj47XG4gICAgLyoqXG4gICAgICogRW1pdHMgYm9vbGVhbiB2YWx1ZXMgaW5kaWNhdGluZyB0aGUgYXV0aGVudGljYXRpb24gc3RhdGUgb2YgdGhlIHVzZXIuIElmIGB0cnVlYCwgaXQgbWVhbnMgYSB1c2VyIGhhcyBhdXRoZW50aWNhdGVkLlxuICAgICAqIFRoaXMgZGVwZW5kcyBvbiB0aGUgdmFsdWUgb2YgYGlzTG9hZGluZyRgLCBzbyB0aGVyZSBpcyBubyBuZWVkIHRvIG1hbnVhbGx5IGNoZWNrIHRoZSBsb2FkaW5nIHN0YXRlIG9mIHRoZSBTREsuXG4gICAgICovXG4gICAgcmVhZG9ubHkgaXNBdXRoZW50aWNhdGVkJDogT2JzZXJ2YWJsZTxib29sZWFuPjtcbiAgICAvKipcbiAgICAgKiBFbWl0cyBkZXRhaWxzIGFib3V0IHRoZSBhdXRoZW50aWNhdGVkIHVzZXIgd2hlbiBgaXNBdXRoZW50aWNhdGVkJGAgaXMgYHRydWVgLlxuICAgICAqL1xuICAgIHJlYWRvbmx5IHVzZXIkOiBPYnNlcnZhYmxlPGFueT47XG4gICAgLyoqXG4gICAgICogRW1pdHMgSUQgdG9rZW4gY2xhaW1zIHdoZW4gYGlzQXV0aGVudGljYXRlZCRgIGlzIGB0cnVlYC5cbiAgICAgKi9cbiAgICByZWFkb25seSBpZFRva2VuQ2xhaW1zJDogT2JzZXJ2YWJsZTxpbXBvcnQoXCJAYXV0aDAvYXV0aDAtc3BhLWpzXCIpLklkVG9rZW4+O1xuICAgIC8qKlxuICAgICAqIEVtaXRzIGVycm9ycyB0aGF0IG9jY3VyIGR1cmluZyBsb2dpbiwgb3Igd2hlbiBjaGVja2luZyBmb3IgYW4gYWN0aXZlIHNlc3Npb24gb24gc3RhcnR1cC5cbiAgICAgKi9cbiAgICByZWFkb25seSBlcnJvciQ6IE9ic2VydmFibGU8RXJyb3I+O1xuICAgIGNvbnN0cnVjdG9yKGF1dGgwQ2xpZW50OiBBdXRoMENsaWVudCwgbG9jYXRpb246IExvY2F0aW9uLCBuYXZpZ2F0b3I6IEFic3RyYWN0TmF2aWdhdG9yKTtcbiAgICAvKipcbiAgICAgKiBDYWxsZWQgd2hlbiB0aGUgc2VydmljZSBpcyBkZXN0cm95ZWRcbiAgICAgKi9cbiAgICBuZ09uRGVzdHJveSgpOiB2b2lkO1xuICAgIC8qKlxuICAgICAqIGBgYGpzXG4gICAgICogbG9naW5XaXRoUmVkaXJlY3Qob3B0aW9ucyk7XG4gICAgICogYGBgXG4gICAgICpcbiAgICAgKiBQZXJmb3JtcyBhIHJlZGlyZWN0IHRvIGAvYXV0aG9yaXplYCB1c2luZyB0aGUgcGFyYW1ldGVyc1xuICAgICAqIHByb3ZpZGVkIGFzIGFyZ3VtZW50cy4gUmFuZG9tIGFuZCBzZWN1cmUgYHN0YXRlYCBhbmQgYG5vbmNlYFxuICAgICAqIHBhcmFtZXRlcnMgd2lsbCBiZSBhdXRvLWdlbmVyYXRlZC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBvcHRpb25zIFRoZSBsb2dpbiBvcHRpb25zXG4gICAgICovXG4gICAgbG9naW5XaXRoUmVkaXJlY3Qob3B0aW9ucz86IFJlZGlyZWN0TG9naW5PcHRpb25zKTogT2JzZXJ2YWJsZTx2b2lkPjtcbiAgICAvKipcbiAgICAgKiBgYGBqc1xuICAgICAqIGF3YWl0IGxvZ2luV2l0aFBvcHVwKG9wdGlvbnMpO1xuICAgICAqIGBgYFxuICAgICAqXG4gICAgICogT3BlbnMgYSBwb3B1cCB3aXRoIHRoZSBgL2F1dGhvcml6ZWAgVVJMIHVzaW5nIHRoZSBwYXJhbWV0ZXJzXG4gICAgICogcHJvdmlkZWQgYXMgYXJndW1lbnRzLiBSYW5kb20gYW5kIHNlY3VyZSBgc3RhdGVgIGFuZCBgbm9uY2VgXG4gICAgICogcGFyYW1ldGVycyB3aWxsIGJlIGF1dG8tZ2VuZXJhdGVkLiBJZiB0aGUgcmVzcG9uc2UgaXMgc3VjY2Vzc2Z1bCxcbiAgICAgKiByZXN1bHRzIHdpbGwgYmUgdmFsaWQgYWNjb3JkaW5nIHRvIHRoZWlyIGV4cGlyYXRpb24gdGltZXMuXG4gICAgICpcbiAgICAgKiBJTVBPUlRBTlQ6IFRoaXMgbWV0aG9kIGhhcyB0byBiZSBjYWxsZWQgZnJvbSBhbiBldmVudCBoYW5kbGVyXG4gICAgICogdGhhdCB3YXMgc3RhcnRlZCBieSB0aGUgdXNlciBsaWtlIGEgYnV0dG9uIGNsaWNrLCBmb3IgZXhhbXBsZSxcbiAgICAgKiBvdGhlcndpc2UgdGhlIHBvcHVwIHdpbGwgYmUgYmxvY2tlZCBpbiBtb3N0IGJyb3dzZXJzLlxuICAgICAqXG4gICAgICogQHBhcmFtIG9wdGlvbnMgVGhlIGxvZ2luIG9wdGlvbnNcbiAgICAgKiBAcGFyYW0gY29uZmlnIENvbmZpZ3VyYXRpb24gZm9yIHRoZSBwb3B1cCB3aW5kb3dcbiAgICAgKi9cbiAgICBsb2dpbldpdGhQb3B1cChvcHRpb25zPzogUG9wdXBMb2dpbk9wdGlvbnMsIGNvbmZpZz86IFBvcHVwQ29uZmlnT3B0aW9ucyk6IE9ic2VydmFibGU8dm9pZD47XG4gICAgLyoqXG4gICAgICogYGBganNcbiAgICAgKiBsb2dvdXQoKTtcbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqIENsZWFycyB0aGUgYXBwbGljYXRpb24gc2Vzc2lvbiBhbmQgcGVyZm9ybXMgYSByZWRpcmVjdCB0byBgL3YyL2xvZ291dGAsIHVzaW5nXG4gICAgICogdGhlIHBhcmFtZXRlcnMgcHJvdmlkZWQgYXMgYXJndW1lbnRzLCB0byBjbGVhciB0aGUgQXV0aDAgc2Vzc2lvbi5cbiAgICAgKiBJZiB0aGUgYGZlZGVyYXRlZGAgb3B0aW9uIGlzIHNwZWNpZmllZCBpdCBhbHNvIGNsZWFycyB0aGUgSWRlbnRpdHkgUHJvdmlkZXIgc2Vzc2lvbi5cbiAgICAgKiBJZiB0aGUgYGxvY2FsT25seWAgb3B0aW9uIGlzIHNwZWNpZmllZCwgaXQgb25seSBjbGVhcnMgdGhlIGFwcGxpY2F0aW9uIHNlc3Npb24uXG4gICAgICogSXQgaXMgaW52YWxpZCB0byBzZXQgYm90aCB0aGUgYGZlZGVyYXRlZGAgYW5kIGBsb2NhbE9ubHlgIG9wdGlvbnMgdG8gYHRydWVgLFxuICAgICAqIGFuZCBhbiBlcnJvciB3aWxsIGJlIHRocm93biBpZiB5b3UgZG8uXG4gICAgICogW1JlYWQgbW9yZSBhYm91dCBob3cgTG9nb3V0IHdvcmtzIGF0IEF1dGgwXShodHRwczovL2F1dGgwLmNvbS9kb2NzL2xvZ291dCkuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gb3B0aW9ucyBUaGUgbG9nb3V0IG9wdGlvbnNcbiAgICAgKi9cbiAgICBsb2dvdXQob3B0aW9ucz86IExvZ291dE9wdGlvbnMpOiB2b2lkO1xuICAgIC8qKlxuICAgICAqIGBgYGpzXG4gICAgICogZ2V0QWNjZXNzVG9rZW5TaWxlbnRseShvcHRpb25zKS5zdWJzY3JpYmUodG9rZW4gPT4gLi4uKVxuICAgICAqIGBgYFxuICAgICAqXG4gICAgICogSWYgdGhlcmUncyBhIHZhbGlkIHRva2VuIHN0b3JlZCwgcmV0dXJuIGl0LiBPdGhlcndpc2UsIG9wZW5zIGFuXG4gICAgICogaWZyYW1lIHdpdGggdGhlIGAvYXV0aG9yaXplYCBVUkwgdXNpbmcgdGhlIHBhcmFtZXRlcnMgcHJvdmlkZWRcbiAgICAgKiBhcyBhcmd1bWVudHMuIFJhbmRvbSBhbmQgc2VjdXJlIGBzdGF0ZWAgYW5kIGBub25jZWAgcGFyYW1ldGVyc1xuICAgICAqIHdpbGwgYmUgYXV0by1nZW5lcmF0ZWQuIElmIHRoZSByZXNwb25zZSBpcyBzdWNjZXNzZnVsLCByZXN1bHRzXG4gICAgICogd2lsbCBiZSB2YWxpZCBhY2NvcmRpbmcgdG8gdGhlaXIgZXhwaXJhdGlvbiB0aW1lcy5cbiAgICAgKlxuICAgICAqIElmIHJlZnJlc2ggdG9rZW5zIGFyZSB1c2VkLCB0aGUgdG9rZW4gZW5kcG9pbnQgaXMgY2FsbGVkIGRpcmVjdGx5IHdpdGggdGhlXG4gICAgICogJ3JlZnJlc2hfdG9rZW4nIGdyYW50LiBJZiBubyByZWZyZXNoIHRva2VuIGlzIGF2YWlsYWJsZSB0byBtYWtlIHRoaXMgY2FsbCxcbiAgICAgKiB0aGUgU0RLIGZhbGxzIGJhY2sgdG8gdXNpbmcgYW4gaWZyYW1lIHRvIHRoZSAnL2F1dGhvcml6ZScgVVJMLlxuICAgICAqXG4gICAgICogVGhpcyBtZXRob2QgbWF5IHVzZSBhIHdlYiB3b3JrZXIgdG8gcGVyZm9ybSB0aGUgdG9rZW4gY2FsbCBpZiB0aGUgaW4tbWVtb3J5XG4gICAgICogY2FjaGUgaXMgdXNlZC5cbiAgICAgKlxuICAgICAqIElmIGFuIGBhdWRpZW5jZWAgdmFsdWUgaXMgZ2l2ZW4gdG8gdGhpcyBmdW5jdGlvbiwgdGhlIFNESyBhbHdheXMgZmFsbHNcbiAgICAgKiBiYWNrIHRvIHVzaW5nIGFuIGlmcmFtZSB0byBtYWtlIHRoZSB0b2tlbiBleGNoYW5nZS5cbiAgICAgKlxuICAgICAqIE5vdGUgdGhhdCBpbiBhbGwgY2FzZXMsIGZhbGxpbmcgYmFjayB0byBhbiBpZnJhbWUgcmVxdWlyZXMgYWNjZXNzIHRvXG4gICAgICogdGhlIGBhdXRoMGAgY29va2llLCBhbmQgdGh1cyB3aWxsIG5vdCB3b3JrIGluIGJyb3dzZXJzIHRoYXQgYmxvY2sgdGhpcmQtcGFydHlcbiAgICAgKiBjb29raWVzIGJ5IGRlZmF1bHQgKFNhZmFyaSwgQnJhdmUsIGV0YykuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gb3B0aW9ucyBUaGUgb3B0aW9ucyBmb3IgY29uZmlndXJpbmcgdGhlIHRva2VuIGZldGNoLlxuICAgICAqL1xuICAgIGdldEFjY2Vzc1Rva2VuU2lsZW50bHkob3B0aW9ucz86IEdldFRva2VuU2lsZW50bHlPcHRpb25zKTogT2JzZXJ2YWJsZTxzdHJpbmc+O1xuICAgIC8qKlxuICAgICAqIGBgYGpzXG4gICAgICogZ2V0VG9rZW5XaXRoUG9wdXAob3B0aW9ucykuc3Vic2NyaWJlKHRva2VuID0+IC4uLilcbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqIEdldCBhbiBhY2Nlc3MgdG9rZW4gaW50ZXJhY3RpdmVseS5cbiAgICAgKlxuICAgICAqIE9wZW5zIGEgcG9wdXAgd2l0aCB0aGUgYC9hdXRob3JpemVgIFVSTCB1c2luZyB0aGUgcGFyYW1ldGVyc1xuICAgICAqIHByb3ZpZGVkIGFzIGFyZ3VtZW50cy4gUmFuZG9tIGFuZCBzZWN1cmUgYHN0YXRlYCBhbmQgYG5vbmNlYFxuICAgICAqIHBhcmFtZXRlcnMgd2lsbCBiZSBhdXRvLWdlbmVyYXRlZC4gSWYgdGhlIHJlc3BvbnNlIGlzIHN1Y2Nlc3NmdWwsXG4gICAgICogcmVzdWx0cyB3aWxsIGJlIHZhbGlkIGFjY29yZGluZyB0byB0aGVpciBleHBpcmF0aW9uIHRpbWVzLlxuICAgICAqL1xuICAgIGdldEFjY2Vzc1Rva2VuV2l0aFBvcHVwKG9wdGlvbnM/OiBHZXRUb2tlbldpdGhQb3B1cE9wdGlvbnMpOiBPYnNlcnZhYmxlPHN0cmluZz47XG4gICAgcHJpdmF0ZSBzaG91bGRIYW5kbGVDYWxsYmFjaztcbiAgICBwcml2YXRlIGhhbmRsZVJlZGlyZWN0Q2FsbGJhY2s7XG59XG4iXX0=