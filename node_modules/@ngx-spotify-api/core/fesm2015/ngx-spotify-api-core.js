import { of } from 'rxjs';
import { flatMap, map, take } from 'rxjs/operators';
import { Injectable, Optional, NgModule, defineInjectable, inject } from '@angular/core';
import { CommonModule } from '@angular/common';
import { HttpParams, HTTP_INTERCEPTORS, HttpClient, HttpClientModule } from '@angular/common/http';

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class ApiConfig {
    constructor() {
        this.baseUrl = 'https://api.spotify.com';
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class AuthorizationConfig {
    constructor() {
        /**
         * \@description This used to prefix the access- and refreshToken inside the local storage.
         */
        this.storagePrefix = 'ngx-spotify-api-';
        /**
         * \@description This is an array of all scopes you need your application to access to. Default all scopes will be requested
         */
        this.scopes = [
            'user-top-read', 'user-read-recently-played',
            'user-read-email', 'user-read-birthdate', 'user-read-private',
            'playlist-read-collaborative', 'playlist-modify-public', 'playlist-read-private', 'playlist-modify-private',
            'user-library-modify', 'user-library-read',
            'user-follow-modify', 'user-follow-read',
            'streaming', 'app-remote-control',
            'user-read-playback-state', 'user-modify-playback-state', 'user-read-currently-playing'
        ];
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class SpotifyApiConfig {
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class AuthInterceptor {
    /**
     * @param {?} apiConfig
     * @param {?} authConfig
     */
    constructor(apiConfig, authConfig) {
        this.apiConfig = apiConfig;
        this.authConfig = authConfig;
    }
    /**
     * @private
     * @param {?} req
     * @return {?}
     */
    attachAuthorizationHeader(req) {
        return this.authConfig.accessToken().pipe(map((token) => {
            return req.clone({
                headers: req.headers.set('Authorization', 'Bearer ' + token)
            });
        }));
    }
    /**
     * @param {?} origReq
     * @param {?} next
     * @return {?}
     */
    intercept(origReq, next) {
        return this.attachAuthorizationHeader(origReq).pipe(flatMap((req) => {
            return next.handle(req);
        }));
    }
}
AuthInterceptor.decorators = [
    { type: Injectable }
];
/** @nocollapse */
AuthInterceptor.ctorParameters = () => [
    { type: ApiConfig },
    { type: AuthorizationConfig }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class CorsInterceptor {
    /**
     * @param {?} apiConfig
     */
    constructor(apiConfig) {
        this.apiConfig = apiConfig;
    }
    /**
     * @param {?} req
     * @param {?} next
     * @return {?}
     */
    intercept(req, next) {
        /** @type {?} */
        let headers = req.headers;
        if (req.url.indexOf(this.apiConfig.baseUrl) > -1) {
            headers = headers.set('Accept', 'application/json');
            headers = headers.set('Content-Type', 'application/json');
        }
        else if (req.url.indexOf('authorize')) ;
        /** @type {?} */
        const newReq = req.clone({
            headers: headers
        });
        return next.handle(newReq);
    }
}
CorsInterceptor.decorators = [
    { type: Injectable }
];
/** @nocollapse */
CorsInterceptor.ctorParameters = () => [
    { type: ApiConfig }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class RemoveNullParamsInterceptor {
    /**
     * @param {?} apiConfig
     */
    constructor(apiConfig) {
        this.apiConfig = apiConfig;
    }
    /**
     * @param {?} req
     * @param {?} next
     * @return {?}
     */
    intercept(req, next) {
        /** @type {?} */
        const params = new HttpParams();
        if (req.url.indexOf(this.apiConfig.baseUrl) > -1) {
            params.keys().forEach((key) => {
                /** @type {?} */
                const param = params.get(key);
                if (param != null && param !== 'null' && param !== 'undefined' && param !== '') {
                    params.set(key, param);
                }
            });
        }
        /** @type {?} */
        const newReq = req.clone({
            'params': params
        });
        return next.handle(newReq);
    }
}
RemoveNullParamsInterceptor.decorators = [
    { type: Injectable }
];
/** @nocollapse */
RemoveNullParamsInterceptor.ctorParameters = () => [
    { type: ApiConfig }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class UnderscoreToCamelcaseInterceptor {
    /**
     * @param {?} apiConfig
     * @param {?} authConfig
     */
    constructor(apiConfig, authConfig) {
        this.apiConfig = apiConfig;
        this.authConfig = authConfig;
    }
    /**
     * @private
     * @param {?} object
     * @return {?}
     */
    transformObjectKeysToCamelCase(object) {
        if (object == null || object === {}) {
            return object;
        }
        /** @type {?} */
        const ret = {};
        Object.keys(object).forEach((key) => {
            /** @type {?} */
            const newKey = key.replace(/[_]([^_])?/g, (v) => {
                return v.replace('_', '').toUpperCase();
            });
            if (object[key] instanceof Array) {
                ret[newKey] = object[key].map((value) => {
                    return this.transformObjectKeysToCamelCase(value);
                });
            }
            else if (object[key] instanceof Object) {
                ret[newKey] = this.transformObjectKeysToCamelCase(object[key]);
            }
            else {
                ret[newKey] = object[key];
            }
        });
        return ret;
    }
    /**
     * @param {?} req
     * @param {?} next
     * @return {?}
     */
    intercept(req, next) {
        return next.handle(req).pipe(map((res) => {
            if (req && req.url && req.url.includes(this.apiConfig.baseUrl) && res.body) {
                return res.clone({
                    body: this.transformObjectKeysToCamelCase(res.body)
                });
            }
            return res;
        }));
    }
}
UnderscoreToCamelcaseInterceptor.decorators = [
    { type: Injectable }
];
/** @nocollapse */
UnderscoreToCamelcaseInterceptor.ctorParameters = () => [
    { type: ApiConfig },
    { type: AuthorizationConfig }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * Http interceptor providers in outside-in order
 * @type {?}
 */
const httpInterceptorProviders = [
    { provide: HTTP_INTERCEPTORS, useClass: AuthInterceptor, multi: true },
    { provide: HTTP_INTERCEPTORS, useClass: CorsInterceptor, multi: true },
    { provide: HTTP_INTERCEPTORS, useClass: RemoveNullParamsInterceptor, multi: true },
    { provide: HTTP_INTERCEPTORS, useClass: UnderscoreToCamelcaseInterceptor, multi: true }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class Album {
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class AlbumSimplified {
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class Artist {
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class ArtistSimplified {
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class AudioAnalysis {
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class AudioFeatures {
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class Category {
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class Context {
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class Copyright {
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class Cursor {
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @template C
 */
class CursorPaging {
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class Device {
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class Error {
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class ExternalId {
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class ExternalUrl {
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class FeaturedPlaylists {
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class Followers {
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class Image {
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @template C
 */
class Paging {
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class PlayHistory {
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class Playback {
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class PlayerError extends Error {
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class Playlist {
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class PlaylistSimplified {
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class PlaylistTrack {
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class Recommendations {
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class RecommendationsSeed {
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class Restriction {
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class SavedAlbum {
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class SavedTrack {
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class SearchResult {
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class Track {
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class TrackCurrent {
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class TrackLink {
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class TrackSimplified {
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class UserPrivate {
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class UserPublic {
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class AlbumService {
    /**
     * @param {?} config
     * @param {?} http
     */
    constructor(config, http) {
        this.config = config;
        this.http = http;
    }
    /**
     * @param {?} id
     * @param {?=} market
     * @return {?}
     */
    getAlbum(id, market) {
        return this.http.get(this.config.baseUrl + '/v1/albums/' + id, {
            params: {
                market: market
            }
        });
    }
    /**
     * @param {?} id
     * @param {?=} limit
     * @param {?=} offset
     * @param {?=} market
     * @return {?}
     */
    getAlbumTracks(id, limit = 20, offset = 0, market) {
        return this.http.get(this.config.baseUrl + '/v1/albums/' + id + '/tracks', {
            params: {
                limit: limit.toString(),
                offset: offset.toString(),
                market: market
            }
        });
    }
    /**
     * @param {?} ids
     * @param {?=} market
     * @return {?}
     */
    getAlbums(ids, market) {
        if (ids == null || ids.length < 1) {
            return of([]);
        }
        else if (ids.length > 20) {
            return of(null);
        }
        return this.http.get(this.config.baseUrl + '/v1/albums', {
            params: {
                ids: ids.join(','),
                market: market
            }
        }).pipe(map((res) => {
            return res.albums;
        }));
    }
}
AlbumService.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root'
            },] }
];
/** @nocollapse */
AlbumService.ctorParameters = () => [
    { type: ApiConfig, decorators: [{ type: Optional }] },
    { type: HttpClient }
];
/** @nocollapse */ AlbumService.ngInjectableDef = defineInjectable({ factory: function AlbumService_Factory() { return new AlbumService(inject(ApiConfig, 8), inject(HttpClient)); }, token: AlbumService, providedIn: "root" });

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class ArtistService {
    /**
     * @param {?} config
     * @param {?} http
     */
    constructor(config, http) {
        this.config = config;
        this.http = http;
    }
    /**
     * @param {?} id
     * @return {?}
     */
    getArtist(id) {
        return this.http.get(this.config.baseUrl + '/v1/artists/' + id, {
            params: {}
        });
    }
    /**
     * @param {?} id
     * @param {?=} includeGroups
     * @param {?=} market
     * @param {?=} limit
     * @param {?=} offset
     * @return {?}
     */
    getArtistsAlbums(id, includeGroups, market, limit = 20, offset = 0) {
        return this.http.get(this.config.baseUrl + '/v1/artists/' + id + '/albums', {
            params: {
                include_groups: includeGroups ? includeGroups.join(',') : null,
                market,
                limit: limit.toString(),
                offset: offset.toString()
            }
        });
    }
    /**
     * @param {?} id
     * @param {?} market
     * @return {?}
     */
    getArtistsTopTracks(id, market) {
        return this.http.get(this.config.baseUrl + '/v1/artists/' + id + '/top-tracks', {
            params: {
                market: market
            }
        }).pipe(map((res) => {
            return res.tracks;
        }));
    }
    /**
     * @param {?} id
     * @return {?}
     */
    getArtistsRelatedArtists(id) {
        return this.http.get(this.config.baseUrl + '/v1/artists/' + id + '/related-artists', {
            params: {}
        }).pipe(map((res) => {
            return res.artists;
        }));
    }
    /**
     * @param {?} ids
     * @return {?}
     */
    getArtists(ids) {
        if (ids == null || ids.length < 1) {
            return of([]);
        }
        else if (ids.length > 50) {
            return of(null);
        }
        return this.http.get(this.config.baseUrl + '/v1/artists/', {
            params: {
                ids: ids.join(',')
            }
        }).pipe(map((res) => {
            return res.artists;
        }));
    }
}
ArtistService.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root'
            },] }
];
/** @nocollapse */
ArtistService.ctorParameters = () => [
    { type: ApiConfig, decorators: [{ type: Optional }] },
    { type: HttpClient }
];
/** @nocollapse */ ArtistService.ngInjectableDef = defineInjectable({ factory: function ArtistService_Factory() { return new ArtistService(inject(ApiConfig, 8), inject(HttpClient)); }, token: ArtistService, providedIn: "root" });

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class BrowseService {
    /**
     * @param {?} config
     * @param {?} http
     */
    constructor(config, http) {
        this.config = config;
        this.http = http;
    }
    /**
     * @param {?} id
     * @param {?=} country
     * @param {?=} locale
     * @return {?}
     */
    getCategory(id, country, locale) {
        return this.http.get(this.config.baseUrl + '/v1/browse/categories/' + id, {
            params: {
                country: country,
                locale: locale
            }
        });
    }
    /**
     * @param {?} id
     * @param {?=} country
     * @param {?=} limit
     * @param {?=} offset
     * @return {?}
     */
    getCategoryPlaylists(id, country, limit = 20, offset = 0) {
        return this.http.get(this.config.baseUrl + '/v1/browse/categories/' + id + '/playlists', {
            params: {
                country: country,
                limit: limit.toString(),
                offset: offset.toString()
            }
        }).pipe(map((res) => {
            return res.playlists;
        }));
    }
    /**
     * @param {?=} country
     * @param {?=} locale
     * @param {?=} limit
     * @param {?=} offset
     * @return {?}
     */
    getCategories(country, locale, limit = 20, offset = 0) {
        return this.http.get(this.config.baseUrl + '/v1/browse/categories', {
            params: {
                country: country,
                locale: locale,
                limit: limit.toString(),
                offset: offset.toString()
            }
        }).pipe(map((list) => {
            return list.categories;
        }));
    }
    /**
     * @param {?=} country
     * @param {?=} locale
     * @param {?=} timestamp
     * @param {?=} limit
     * @param {?=} offset
     * @return {?}
     */
    getFeaturedPlaylists(country, locale, timestamp = new Date(), limit = 20, offset = 0) {
        return this.http.get(this.config.baseUrl + '/v1/browse/featured-playlists', {
            params: {
                country,
                locale,
                timestamp: timestamp.toISOString(),
                limit: limit.toString(),
                offset: offset.toString()
            }
        });
    }
    /**
     * @param {?=} country
     * @param {?=} limit
     * @param {?=} offset
     * @return {?}
     */
    getNewReleases(country, limit = 20, offset = 0) {
        return this.http.get(this.config.baseUrl + '/v1/browse/new-releases', {
            params: {
                country,
                limit: limit.toString(),
                offset: offset.toString()
            }
        }).pipe(map(({ albums }) => {
            return albums;
        }));
    }
}
BrowseService.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root'
            },] }
];
/** @nocollapse */
BrowseService.ctorParameters = () => [
    { type: ApiConfig, decorators: [{ type: Optional }] },
    { type: HttpClient }
];
/** @nocollapse */ BrowseService.ngInjectableDef = defineInjectable({ factory: function BrowseService_Factory() { return new BrowseService(inject(ApiConfig, 8), inject(HttpClient)); }, token: BrowseService, providedIn: "root" });

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class FollowService {
    /**
     * @param {?} config
     * @param {?} http
     */
    constructor(config, http) {
        this.config = config;
        this.http = http;
    }
    /**
     * @param {?} ids
     * @return {?}
     */
    isFollowingArtists(ids) {
        if (ids === null || ids.length === 0) {
            return of([]);
        }
        else if (ids.length > 50) {
            return of(null);
        }
        return this.http.get(this.config.baseUrl + '/v1/me/following/contains', {
            params: {
                type: 'artist',
                ids: ids.join(',')
            }
        });
    }
    /**
     * @param {?} ids
     * @return {?}
     */
    isFollowingUsers(ids) {
        if (ids === null || ids.length === 0) {
            return of([]);
        }
        else if (ids.length > 50) {
            return of(null);
        }
        return this.http.get(this.config.baseUrl + '/v1/me/following/contains', {
            params: {
                type: 'user',
                ids: ids.join(',')
            }
        });
    }
    /**
     * @param {?} playlistId
     * @param {?} usersToCheck
     * @return {?}
     */
    areFollowingPlaylist(playlistId, usersToCheck) {
        if (usersToCheck === null || usersToCheck.length === 0) {
            return of([]);
        }
        else if (usersToCheck.length > 5) {
            return of(null);
        }
        return this.http.get(this.config.baseUrl + `/v1/playlists/${playlistId}/followers/contains`, {
            params: {
                ids: usersToCheck.join(',')
            }
        });
    }
    /**
     * @param {?} ids
     * @return {?}
     */
    followArtists(ids) {
        if (ids === null || ids.length === 0) {
            return of(false);
        }
        else if (ids.length > 50) {
            return of(false);
        }
        return this.http.put(this.config.baseUrl + '/v1/me/following', {}, {
            params: {
                type: 'artist',
                ids: ids.join(',')
            }
        }).pipe(map(() => {
            return true;
        }));
    }
    /**
     * @param {?} ids
     * @return {?}
     */
    followUsers(ids) {
        if (ids === null || ids.length === 0) {
            return of(false);
        }
        else if (ids.length > 50) {
            return of(false);
        }
        return this.http.put(this.config.baseUrl + '/v1/me/following', {}, {
            params: {
                type: 'user',
                ids: ids.join(',')
            }
        }).pipe(map(() => {
            return true;
        }));
    }
    /**
     * @param {?} id
     * @param {?=} isPublic
     * @return {?}
     */
    followPlaylist(id, isPublic = false) {
        return this.http.put(this.config.baseUrl + `/v1/playlists/${id}/followers`, {
            public: isPublic
        }).pipe(map(() => {
            return true;
        }));
    }
    /**
     * @param {?=} limit
     * @param {?=} after
     * @return {?}
     */
    getFollowedArtists(limit = 20, after) {
        return this.http.get(this.config.baseUrl + `/v1/me/following`, {
            params: {
                type: 'artist',
                limit: limit.toString(),
                after: after
            }
        });
    }
    /**
     * @param {?} ids
     * @return {?}
     */
    unfollowArtists(ids) {
        if (ids === null || ids.length === 0) {
            return of(false);
        }
        else if (ids.length > 50) {
            return of(false);
        }
        return this.http.delete(this.config.baseUrl + '/v1/me/following', {
            params: {
                type: 'artist',
                ids: ids.join(',')
            }
        }).pipe(map(() => true));
    }
    /**
     * @param {?} ids
     * @return {?}
     */
    unfollowUsers(ids) {
        if (ids === null || ids.length === 0) {
            return of(false);
        }
        else if (ids.length > 50) {
            return of(false);
        }
        return this.http.delete(this.config.baseUrl + '/v1/me/following', {
            params: {
                type: 'user',
                ids: ids.join(',')
            }
        }).pipe(map(() => true));
    }
    /**
     * @param {?} id
     * @return {?}
     */
    unfollowPlaylist(id) {
        return this.http.delete(this.config.baseUrl + `/v1/playlists/${id}/followers`).pipe(map(() => true));
    }
}
FollowService.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root'
            },] }
];
/** @nocollapse */
FollowService.ctorParameters = () => [
    { type: ApiConfig, decorators: [{ type: Optional }] },
    { type: HttpClient }
];
/** @nocollapse */ FollowService.ngInjectableDef = defineInjectable({ factory: function FollowService_Factory() { return new FollowService(inject(ApiConfig, 8), inject(HttpClient)); }, token: FollowService, providedIn: "root" });

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class LibraryService {
    /**
     * @param {?} config
     * @param {?} http
     */
    constructor(config, http) {
        this.config = config;
        this.http = http;
    }
    /**
     * @param {?} ids
     * @return {?}
     */
    areSavedAlbums(ids) {
        if (ids === null || ids === undefined || ids.length === 0) {
            return of([]);
        }
        else if (ids.length > 50) {
            return of(null);
        }
        return this.http.get(this.config.baseUrl + `/v1/me/albums/contains`, {
            params: {
                ids: ids.join(',')
            }
        });
    }
    /**
     * @param {?} ids
     * @return {?}
     */
    areSavedTracks(ids) {
        if (ids === null || ids === undefined || ids.length === 0) {
            return of([]);
        }
        else if (ids.length > 50) {
            return of(null);
        }
        return this.http.get(this.config.baseUrl + `/v1/me/tracks/contains`, {
            params: {
                ids: ids.join(',')
            }
        });
    }
    /**
     * @param {?=} limit
     * @param {?=} offset
     * @param {?=} market
     * @return {?}
     */
    getSavedAlbums(limit = 20, offset = 0, market) {
        return this.http.get(this.config.baseUrl + `/v1/me/albums`, {
            params: {
                limit: limit.toString(),
                offset: offset.toString(),
                market
            }
        });
    }
    /**
     * @param {?=} limit
     * @param {?=} offset
     * @param {?=} market
     * @return {?}
     */
    getSavedTracks(limit = 20, offset = 0, market) {
        return this.http.get(this.config.baseUrl + `/v1/me/tracks`, {
            params: {
                limit: limit.toString(),
                offset: offset.toString(),
                market
            }
        });
    }
    /**
     * @param {?} ids
     * @return {?}
     */
    saveAlbums(ids) {
        if (ids === null || ids === undefined || ids.length === 0) {
            return of(false);
        }
        else if (ids.length > 50) {
            return of(false);
        }
        return this.http.put(this.config.baseUrl + `/v1/me/albums`, {}, {
            params: {
                ids: ids.join(',')
            }
        }).pipe(map(() => true));
    }
    /**
     * @param {?} ids
     * @return {?}
     */
    removeAlbums(ids) {
        if (ids === null || ids === undefined || ids.length === 0) {
            return of(false);
        }
        else if (ids.length > 50) {
            return of(false);
        }
        return this.http.delete(this.config.baseUrl + `/v1/me/albums`, {
            params: {
                ids: ids.join(',')
            }
        }).pipe(map(() => true));
    }
    /**
     * @param {?} ids
     * @return {?}
     */
    saveTracks(ids) {
        if (ids === null || ids === undefined || ids.length === 0) {
            return of(false);
        }
        else if (ids.length > 50) {
            return of(false);
        }
        return this.http.put(this.config.baseUrl + `/v1/me/tracks`, {}, {
            params: {
                ids: ids.join(',')
            }
        }).pipe(map(() => true));
    }
    /**
     * @param {?} ids
     * @return {?}
     */
    removeTracks(ids) {
        if (ids === null || ids === undefined || ids.length === 0) {
            return of(false);
        }
        else if (ids.length > 50) {
            return of(false);
        }
        return this.http.delete(this.config.baseUrl + `/v1/me/tracks`, {
            params: {
                ids: ids.join(',')
            }
        }).pipe(map(() => true));
    }
}
LibraryService.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root'
            },] }
];
/** @nocollapse */
LibraryService.ctorParameters = () => [
    { type: ApiConfig, decorators: [{ type: Optional }] },
    { type: HttpClient }
];
/** @nocollapse */ LibraryService.ngInjectableDef = defineInjectable({ factory: function LibraryService_Factory() { return new LibraryService(inject(ApiConfig, 8), inject(HttpClient)); }, token: LibraryService, providedIn: "root" });

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class PersonalizationService {
    /**
     * @param {?} config
     * @param {?} http
     */
    constructor(config, http) {
        this.config = config;
        this.http = http;
    }
    /**
     * @param {?=} limit
     * @param {?=} offset
     * @param {?=} timeRange
     * @return {?}
     */
    getTopArtists(limit = 20, offset = 0, timeRange) {
        return this.http.get(this.config.baseUrl + `/v1/me/top/artists`, {
            params: {
                limit: limit.toString(),
                offset: offset.toString(),
                time_range: timeRange
            }
        });
    }
    /**
     * @param {?=} limit
     * @param {?=} offset
     * @param {?=} timeRange
     * @return {?}
     */
    getTopTracks(limit = 20, offset = 0, timeRange) {
        return this.http.get(this.config.baseUrl + `/v1/me/top/tracks`, {
            params: {
                limit: limit.toString(),
                offset: offset.toString(),
                time_range: timeRange
            }
        });
    }
}
PersonalizationService.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root'
            },] }
];
/** @nocollapse */
PersonalizationService.ctorParameters = () => [
    { type: ApiConfig, decorators: [{ type: Optional }] },
    { type: HttpClient }
];
/** @nocollapse */ PersonalizationService.ngInjectableDef = defineInjectable({ factory: function PersonalizationService_Factory() { return new PersonalizationService(inject(ApiConfig, 8), inject(HttpClient)); }, token: PersonalizationService, providedIn: "root" });

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class PlayerService {
    /**
     * @param {?} config
     * @param {?} http
     */
    constructor(config, http) {
        this.config = config;
        this.http = http;
    }
    /**
     * @param {?=} deviceId
     * @return {?}
     */
    nextTrack(deviceId) {
        return this.http.post(this.config.baseUrl + `/v1/me/player/next`, {}, {
            params: {
                device_id: deviceId
            }
        }).pipe(take(1), map(() => {
            return true;
        }));
    }
    /**
     * @param {?=} deviceId
     * @return {?}
     */
    previousTrack(deviceId) {
        return this.http.post(this.config.baseUrl + `/v1/me/player/previous`, {}, {
            params: {
                device_id: deviceId
            }
        }).pipe(take(1), map(() => {
            return true;
        }));
    }
    /**
     * @param {?} positionMs
     * @param {?=} deviceId
     * @return {?}
     */
    seekToPosition(positionMs, deviceId) {
        return this.http.put(this.config.baseUrl + `/v1/me/player/seek`, {}, {
            params: {
                position_ms: positionMs.toString(),
                device_id: deviceId
            }
        }).pipe(take(1), map(() => {
            return true;
        }));
    }
    /**
     * @return {?}
     */
    getAvailableDevices() {
        return this.http.get(this.config.baseUrl + `/v1/me/player/devices`).pipe(map((list) => list.devices));
    }
    /**
     * @param {?} shuffle
     * @param {?=} deviceId
     * @return {?}
     */
    toggleShuffle(shuffle, deviceId) {
        return this.http.put(this.config.baseUrl + `/v1/me/player/shuffle`, {}, {
            params: {
                state: shuffle.toString(),
                device_id: deviceId
            }
        }).pipe(take(1), map(() => {
            return true;
        }));
    }
    /**
     *
     * @param {?} deviceIds Although an array is accepted, only a single deviceId is currently supported
     * @param {?=} forcePlay
     * @return {?}
     */
    transferPlayback(deviceIds, forcePlay = false) {
        return this.http.put(this.config.baseUrl + `/v1/me/player`, {
            device_ids: deviceIds.join(','),
            play: forcePlay
        }).pipe(take(1), map(() => {
            return true;
        }));
    }
    /**
     * @param {?=} limit
     * @param {?=} before
     * @param {?=} after
     * @return {?}
     */
    getRecentlyPlayedTracks(limit = 20, before, after = 0) {
        return this.http.get(this.config.baseUrl + `/v1/me/player/recently-played`, {
            params: {
                limit: limit.toString(),
                before: (before ? before.toString() : undefined),
                after: after.toString(),
            }
        });
    }
    /**
     * @param {?=} deviceId
     * @param {?=} context
     * @param {?=} uris
     * @param {?=} offset
     * @param {?=} positionMs
     * @return {?}
     */
    startPlayback(deviceId, context, uris, offset, positionMs) {
        return this.http.put(this.config.baseUrl + `/v1/me/player/play`, {
            context_uri: context,
            uris: uris,
            offset: offset,
            position_ms: positionMs
        }, {
            params: {
                device_id: deviceId
            }
        }).pipe(take(1), map(() => {
            return true;
        }));
    }
    /**
     * @param {?=} deviceId
     * @return {?}
     */
    pausePlayback(deviceId) {
        return this.http.put(this.config.baseUrl + `/v1/me/player/pause`, {}, {
            params: {
                device_id: deviceId
            }
        }).pipe(take(1), map(() => {
            return true;
        }));
    }
    /**
     * @param {?} mode
     * @param {?=} deviceId
     * @return {?}
     */
    toggleRepeatMode(mode, deviceId) {
        return this.http.put(this.config.baseUrl + `/v1/me/player/repeat`, {}, {
            params: {
                state: mode,
                device_id: deviceId
            }
        }).pipe(take(1), map(() => {
            return true;
        }));
    }
    /**
     * @param {?=} market
     * @return {?}
     */
    getPlayback(market) {
        return this.http.get(this.config.baseUrl + `/v1/me/player`, {
            params: {
                market: market
            }
        });
    }
    /**
     * @param {?=} market
     * @return {?}
     */
    getCurrentlyPlayingTrack(market) {
        return this.http.get(this.config.baseUrl + `/v1/me/player/currently-playing`, {
            params: {
                market: market
            }
        });
    }
    /**
     * @param {?} volume
     * @param {?=} deviceId
     * @return {?}
     */
    setPlaybackVolume(volume, deviceId) {
        return this.http.put(this.config.baseUrl + `/v1/me/player/volume`, {}, {
            params: {
                volume_percent: volume.toString(),
                device_id: deviceId
            }
        }).pipe(take(1), map(() => {
            return true;
        }));
    }
}
PlayerService.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root'
            },] }
];
/** @nocollapse */
PlayerService.ctorParameters = () => [
    { type: ApiConfig, decorators: [{ type: Optional }] },
    { type: HttpClient }
];
/** @nocollapse */ PlayerService.ngInjectableDef = defineInjectable({ factory: function PlayerService_Factory() { return new PlayerService(inject(ApiConfig, 8), inject(HttpClient)); }, token: PlayerService, providedIn: "root" });

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class PlaylistService {
    /**
     * @param {?} config
     * @param {?} http
     */
    constructor(config, http) {
        this.config = config;
        this.http = http;
    }
    /**
     * @param {?} id
     * @param {?} uris
     * @param {?} position
     * @return {?}
     */
    addTracksToPlaylist(id, uris, position) {
        if (typeof uris !== typeof [] || uris.length < 1 || uris.length > 100) {
            return of(null);
        }
        return this.http.post(this.config.baseUrl + `/v1/playlists/${id}/tracks`, {
            uris: uris,
            position: position
        }).pipe(map(({ snapshotId }) => {
            return snapshotId;
        }));
    }
    /**
     * @param {?} id
     * @param {?} uris
     * @return {?}
     */
    removeTracksFromPlaylist(id, uris) {
        if (typeof uris !== typeof [] || uris.length < 1 || uris.length > 100) {
            return of(null);
        }
        return this.http.request('DELETE', this.config.baseUrl + `/v1/playlists/${id}/tracks`, {
            body: {
                tracks: uris.map((uri) => {
                    return { uri: uri };
                })
            }
        }).pipe(map(({ snapshotId }) => {
            return snapshotId;
        }));
    }
    /**
     * @param {?} id
     * @param {?=} market
     * @return {?}
     */
    getPlaylist(id, market) {
        return this.http.get(this.config.baseUrl + `/v1/playlists/${id}`, {
            params: {
                market: market || ''
            }
        });
    }
    /**
     * @param {?} id
     * @param {?} market
     * @param {?=} limit
     * @param {?=} offset
     * @return {?}
     */
    getPlaylistTracks(id, market, limit = 100, offset = 0) {
        return this.http.get(this.config.baseUrl + `/v1/playlists/${id}/tracks`, {
            params: {
                limit: limit.toString(),
                offset: offset.toString(),
                market: market
            }
        });
    }
    /**
     * @param {?} id
     * @return {?}
     */
    getPlaylistCover(id) {
        return this.http.get(this.config.baseUrl + `/v1/playlists/${id}/images`);
    }
    /**
     *
     * @param {?} id id of playlist
     * @param {?} image base64 encoded jpeg (max. 256KB)
     * @return {?}
     */
    uploadPlaylistCover(id, image) {
        return this.http.put(this.config.baseUrl + `/v1/playlists/${id}/images`, image, {
            headers: {
                'Content-Type': 'image/jpeg'
            }
        }).pipe(map((res) => {
            return true;
        }));
    }
    /**
     *
     * @param {?=} limit min=1, default=20, max=50
     * @param {?=} offset min=0, default=0, max=100000
     * @return {?}
     */
    getOwnPlaylists(limit = 20, offset = 0) {
        return this.http.get(this.config.baseUrl + `/v1/me/playlists`, {
            params: {
                limit: limit.toString(),
                offset: offset.toString()
            }
        });
    }
    /**
     * @param {?} id
     * @param {?=} name
     * @param {?=} isPublic
     * @param {?=} isCollaborative
     * @param {?=} description
     * @return {?}
     */
    updateDetails(id, name, isPublic, isCollaborative, description) {
        return this.http.put(this.config.baseUrl + `/v1/playlists/${id}`, {
            name,
            public: isPublic,
            collaborative: isCollaborative,
            description: description
        }, {
            headers: {
                'Content-Type': 'application/json'
            }
        }).pipe(map((res) => {
            return true;
        }));
    }
    /**
     * @param {?} id
     * @param {?=} limit
     * @param {?=} offset
     * @return {?}
     */
    getUsersPlaylists(id, limit = 20, offset = 0) {
        return this.http.get(this.config.baseUrl + `/v1/users/${id}/playlists`, {
            params: {
                limit: limit.toString(),
                offset: offset.toString()
            }
        });
    }
    /**
     * @param {?} id
     * @param {?} uris
     * @return {?}
     */
    replacePlaylistTracks(id, uris) {
        return this.http.put(this.config.baseUrl + `/v1/playlists/${id}/tracks`, {
            uris: uris
        }, {
            headers: {
                'Content-Type': 'application/json'
            }
        }).pipe(map((res) => {
            return true;
        }));
    }
    /**
     * @param {?} userid
     * @param {?} name
     * @param {?} isPublic
     * @param {?} isCollaborative
     * @param {?=} description
     * @return {?}
     */
    createPlaylists(userid, name, isPublic, isCollaborative, description = '') {
        return this.http.post(this.config.baseUrl + `/v1/users/${userid}/playlists`, {
            name,
            public: isPublic,
            collaborative: isCollaborative,
            description
        }, {
            headers: {
                'Content-Type': 'application/json'
            }
        });
    }
    /**
     * @param {?} id
     * @param {?} rangeStart
     * @param {?} rangeLength
     * @param {?} insertBefore
     * @param {?=} snapshot
     * @return {?}
     */
    reorderPlaylistTracks(id, rangeStart, rangeLength, insertBefore, snapshot) {
        return this.http.put(this.config.baseUrl + `/v1/playlists/${id}/tracks`, {
            range_start: rangeStart,
            insert_before: insertBefore,
            range_length: rangeLength,
            snapshot_id: snapshot
        }, {
            headers: {
                'Content-Type': 'application/json'
            }
        }).pipe(map((s) => s.snapshotId));
    }
}
PlaylistService.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root'
            },] }
];
/** @nocollapse */
PlaylistService.ctorParameters = () => [
    { type: ApiConfig, decorators: [{ type: Optional }] },
    { type: HttpClient }
];
/** @nocollapse */ PlaylistService.ngInjectableDef = defineInjectable({ factory: function PlaylistService_Factory() { return new PlaylistService(inject(ApiConfig, 8), inject(HttpClient)); }, token: PlaylistService, providedIn: "root" });

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class SearchService {
    /**
     * @param {?} config
     * @param {?} http
     */
    constructor(config, http) {
        this.config = config;
        this.http = http;
    }
    /**
     * @param {?} searchTerms
     * @param {?} types
     * @param {?=} market
     * @param {?=} limit
     * @param {?=} offset
     * @param {?=} includeExternal
     * @return {?}
     */
    search(searchTerms, types, market, limit = 20, offset = 0, includeExternal) {
        return this.http.get(this.config.baseUrl + `/v1/search`, {
            params: {
                q: encodeURIComponent(searchTerms),
                type: types.join(','),
                market: market,
                limit: limit.toString(),
                offset: offset.toString(),
                include_external: includeExternal ? 'audio' : undefined
            }
        });
    }
}
SearchService.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root'
            },] }
];
/** @nocollapse */
SearchService.ctorParameters = () => [
    { type: ApiConfig, decorators: [{ type: Optional }] },
    { type: HttpClient }
];
/** @nocollapse */ SearchService.ngInjectableDef = defineInjectable({ factory: function SearchService_Factory() { return new SearchService(inject(ApiConfig, 8), inject(HttpClient)); }, token: SearchService, providedIn: "root" });

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class TrackService {
    /**
     * @param {?} config
     * @param {?} http
     */
    constructor(config, http) {
        this.config = config;
        this.http = http;
    }
    /**
     * @param {?} id
     * @param {?=} market
     * @return {?}
     */
    getTrack(id, market) {
        return this.http.get(this.config.baseUrl + `/v1/tracks/${id}`, {
            params: {
                market
            }
        });
    }
    /**
     * @param {?} id
     * @return {?}
     */
    getAudioFeatures(id) {
        return this.http.get(this.config.baseUrl + `/v1/audio-features/${id}`);
    }
    /**
     * @param {?} id
     * @return {?}
     */
    getAudioAnalysis(id) {
        return this.http.get(this.config.baseUrl + `/v1/audio-analysis/${id}`);
    }
    /**
     * @param {?} ids
     * @param {?=} market
     * @return {?}
     */
    getTracks(ids, market) {
        if (ids === undefined || ids === null || ids.length === 0) {
            return of([]);
        }
        else if (ids.length > 50) {
            return of(null);
        }
        return this.http.get(this.config.baseUrl + `/v1/tracks`, {
            params: {
                ids: ids.join(','),
                market: market || ''
            }
        }).pipe(map(({ tracks }) => tracks));
    }
    /**
     * @param {?} ids
     * @return {?}
     */
    getSeveralAudioFeatures(ids) {
        if (ids === undefined || ids === null || ids.length === 0) {
            return of([]);
        }
        else if (ids.length > 50) {
            return of(null);
        }
        return this.http.get(this.config.baseUrl + `/v1/audio-features`, {
            params: {
                ids: ids.join(',')
            }
        }).pipe(map(({ audioFeatures }) => audioFeatures));
    }
}
TrackService.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root'
            },] }
];
/** @nocollapse */
TrackService.ctorParameters = () => [
    { type: ApiConfig, decorators: [{ type: Optional }] },
    { type: HttpClient }
];
/** @nocollapse */ TrackService.ngInjectableDef = defineInjectable({ factory: function TrackService_Factory() { return new TrackService(inject(ApiConfig, 8), inject(HttpClient)); }, token: TrackService, providedIn: "root" });

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class UserService {
    /**
     * @param {?} config
     * @param {?} http
     */
    constructor(config, http) {
        this.config = config;
        this.http = http;
    }
    /**
     * @param {?} id
     * @return {?}
     */
    getUser(id) {
        return this.http.get(this.config.baseUrl + `/v1/users/${id}`);
    }
    /**
     * @return {?}
     */
    getCurrentUser() {
        return this.http.get(this.config.baseUrl + `/v1/me`);
    }
}
UserService.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root'
            },] }
];
/** @nocollapse */
UserService.ctorParameters = () => [
    { type: ApiConfig, decorators: [{ type: Optional }] },
    { type: HttpClient }
];
/** @nocollapse */ UserService.ngInjectableDef = defineInjectable({ factory: function UserService_Factory() { return new UserService(inject(ApiConfig, 8), inject(HttpClient)); }, token: UserService, providedIn: "root" });

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class NgxSpotifyApiModule {
    /**
     * @param {?} config
     * @return {?}
     */
    static forRoot(config) {
        config = {
            api: Object.assign({}, new ApiConfig(), config.api),
            authorization: Object.assign({}, new AuthorizationConfig(), config.authorization)
        };
        return {
            ngModule: NgxSpotifyApiModule,
            providers: [
                { provide: AuthorizationConfig, useValue: config.authorization },
                { provide: ApiConfig, useValue: config.api },
            ]
        };
    }
}
NgxSpotifyApiModule.decorators = [
    { type: NgModule, args: [{
                imports: [
                    CommonModule,
                    HttpClientModule,
                ],
                providers: [
                    ArtistService,
                    AlbumService,
                    BrowseService,
                    FollowService,
                    LibraryService,
                    PersonalizationService,
                    PlayerService,
                    PlaylistService,
                    SearchService,
                    TrackService,
                    UserService,
                    httpInterceptorProviders
                ]
            },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

export { httpInterceptorProviders, AuthInterceptor, CorsInterceptor, RemoveNullParamsInterceptor, UnderscoreToCamelcaseInterceptor, Album, AlbumSimplified, Artist, ArtistSimplified, AudioAnalysis, AudioFeatures, Category, Context, Copyright, Cursor, CursorPaging, Device, Error, ExternalId, ExternalUrl, FeaturedPlaylists, Followers, Image, Paging, PlayHistory, Playback, PlayerError, Playlist, PlaylistSimplified, PlaylistTrack, Recommendations, RecommendationsSeed, Restriction, SavedAlbum, SavedTrack, SearchResult, Track, TrackCurrent, TrackLink, TrackSimplified, UserPrivate, UserPublic, ApiConfig, AuthorizationConfig, SpotifyApiConfig, AlbumService, ArtistService, BrowseService, FollowService, LibraryService, PersonalizationService, PlayerService, PlaylistService, SearchService, TrackService, UserService, NgxSpotifyApiModule };

//# sourceMappingURL=ngx-spotify-api-core.js.map